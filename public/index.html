<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="xuyuli, blog" />








  <link rel="shortcut icon" type="image/x-icon" href="/bb.png?v=5.1.1" />






<meta name="description" content="淡泊明志,宁静致远">
<meta property="og:type" content="website">
<meta property="og:title" content="星辰大海">
<meta property="og:url" content="https://xuyuli.github.io/index.html">
<meta property="og:site_name" content="星辰大海">
<meta property="og:description" content="淡泊明志,宁静致远">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="星辰大海">
<meta name="twitter:description" content="淡泊明志,宁静致远">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xuyuli.github.io/"/>





  <title>星辰大海</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">星辰大海</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">知识的海洋是星辰大海</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Kategorien
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            Über
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            Commonweal 404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xuyuli.github.io/2017/05/16/浅析事务原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xyl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/bb.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/浅析事务原理/" itemprop="url">浅析事务原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-16T10:28:10+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><pre><code>事务是对一组对数据操作的封装,尤其是多线程对共享数据的操作,由于要符合人类的逻辑正确性,所以制定了一套标准,来规范对共享数据的操作  
这种规范,就是事务.其核心,就是  锁   +   并行.  还有就是 多版本并发控制(mvcc) 来解决锁的效率低下.
</code></pre><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><p>acid 原子性,一致性,隔离性,持久性</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><pre><code>关于原子性,有很多的文章,但是都太难懂了.上面说了,事务是对一直对数据操作的封装.原子性,要么全部成功,要么全部失败.这是事务最基本的规范,为什么要制定这个规范,这个很好理解,如果没有这个规范,那么数据就要乱了
那么,数据库是怎么实现的呢,其实很简单,就是记日志(undo日志).其实很多看似很高大上的特性都是使用很简单的原理来实现的.当实务操作之前,记录undo日志(准确的说是在每个对数据的操作前都记录undo日志),当事务失败时,使用undo日志将数据复原.是不是很简单,就像我们发布版本的时候一样,发布前记录一个备份,发布失败,就使用备份代码.
</code></pre><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><pre><code>其实这个一致性是基于原子性的,对原子性的补充.当人们拥有原子性的准则时候,就不怕事务执行失败了,满足人们的逻辑.但是,人们又发现.如果多线程的情况下,比如线程1,a账号给b账号转账100元.线程2,c账号给a账号转账100元.如果在线程2执行后,线程1失败了,那么它将回滚,将a账号的数据复原.这样的话就不行了,因为c给a的钱没了.
这个就不符合人类的逻辑.所以,又制定了一致性原则.只要记住,这个原则一定要符合人类的逻辑,这两笔转账都要符合逻辑,不会出现c转账了,钱没了.
那么怎么实现一致性呢,其实也很简单,就是加锁.当线程1执行时,对a,b账号加锁,当执行完,再释放锁.这样其实就达到了一致性.
那样,我们有没有发现,其实这时候,事务跟实物的关系  就好像是一个队列,所有的事务操作都在这个队列里面,事务跟事务的关系只能是要么你在我前面,要么你在我后面,绝不会你在我内部.
这样,事务的一致性是达到了,但是效率极低,这个大家也能很快想到,锁的级别越高,范围越广,其他线程等待的时间越长,效率越低.
</code></pre><h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><pre><code>其实,隔离性就是人们为了满足性能,而对一致性产生的破坏.人们发现,如果严格执行一致性,所有事务操作都是串行的,那么效率极低,所以人们就发明了隔离性这个东西,来对一些操作做并行话处理,这样既能达到数据安全,又能获取一定的效率.
这个时候我们就来分析下,事务操作的组合有哪几种.其实也很简单,排列组合:
读读,读写,写读,写写.4种.这四种,容易产生问题的有哪些呢,读读,其实是安全的,写写,优化性不高(难度很大),能优化的就只有,读写,写读了.
那么,这四种,哪些可以并行操作呢,这就形成了隔离性的4个隔离级别:由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题.
这四个隔离级别,其实对锁的封装.锁分读锁,写锁两种.来跟上面的4种排列组合对应.就产生了4种隔离级别.
隔离级别就是对数据安全的程度划分.Serializable就是严格的串行,所有的读写组合都排队,这个可以解决所有的逻辑问题,但效率最低.
</code></pre><h4 id="mvcc-多版本并发控制"><a href="#mvcc-多版本并发控制" class="headerlink" title="mvcc 多版本并发控制"></a>mvcc 多版本并发控制</h4><pre><code>现在的数据库大多采用mvcc的设计模式,他能达到效率跟逻辑正确的平衡效果.上面说了,可优化的有读写,写读操作.如果只使用加锁策略,效率很低,因为我在写的时候,其他人读都不行.
那么怎么办呢,大家想想,我们很多人一起开发同一个项目的时候怎么做的.对,开一个版本号.比如说,线程1,a给b转账.这个时候线程2,来读取b的账号余额.那怎么办呢?
线程1读取的时候,新建个数据版本1(原来的数据版本是0).那么线程2来的时候,就读取版本0,这个就规避了并发产生的逻辑问题.当线程1执行完,将数据版本0删除,那么其他的线程就来读取线程1的版本.万事大吉!ok了
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xuyuli.github.io/2017/05/16/分布式事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xyl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/bb.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/分布式事务/" itemprop="url">分布式事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-16T10:26:32+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xuyuli.github.io/2017/05/11/tomcat源码分析之getOutputStream-与getWriter-的关系-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xyl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/bb.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/11/tomcat源码分析之getOutputStream-与getWriter-的关系-md/" itemprop="url">tomcat源码分析之getOutputStream()与getWriter()的关系.md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-11T19:20:18+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用tomcat的时候,如果同时使用了getOutputStream()与getWriter()就会抛<br>java.lang.IllegalStateException: getOutputStream() has already been called for this response异常</p>
<pre><code>这是因为,如果同时使用了getOutputStream是直接发送给客户端,而getWriter则是放到了一个缓存里(stringbuf)里,   
如果同时存在两种操作,务必灰引起紊乱,所以,tomcat会避开这种操作.
</code></pre><h3 id="先来看下getOutputStream-方法"><a href="#先来看下getOutputStream-方法" class="headerlink" title="先来看下getOutputStream()方法"></a>先来看下getOutputStream()方法</h3><h4 id="如果是nio模式-该方法返回的是NioServletOutputStream类"><a href="#如果是nio模式-该方法返回的是NioServletOutputStream类" class="headerlink" title="如果是nio模式,该方法返回的是NioServletOutputStream类,"></a>如果是nio模式,该方法返回的是NioServletOutputStream类,</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">private int doWriteInternal (boolean block, byte[] b, int off, int len)</div><div class="line">            throws IOException &#123;</div><div class="line">        channel.getBufHandler().getWriteBuffer().clear();</div><div class="line">        channel.getBufHandler().getWriteBuffer().put(b, off, len);</div><div class="line">        channel.getBufHandler().getWriteBuffer().flip();</div><div class="line"></div><div class="line">        int written = 0;</div><div class="line">        NioEndpoint.KeyAttachment att =</div><div class="line">                (NioEndpoint.KeyAttachment) channel.getAttachment();</div><div class="line">        if (att == null) &#123;</div><div class="line">            throw new IOException(&quot;Key must be cancelled&quot;);</div><div class="line">        &#125;</div><div class="line">        long writeTimeout = att.getWriteTimeout();</div><div class="line">        Selector selector = null;</div><div class="line">        try &#123;</div><div class="line">            selector = pool.get();</div><div class="line">        &#125; catch ( IOException x ) &#123;</div><div class="line">            //ignore</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            written = pool.write(channel.getBufHandler().getWriteBuffer(),</div><div class="line">                    channel, selector, writeTimeout, block);</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (selector != null) &#123;</div><div class="line">                pool.put(selector);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (written &lt; len) &#123;</div><div class="line">            channel.getPoller().add(channel, SelectionKey.OP_WRITE);</div><div class="line">        &#125;</div><div class="line">        return written;</div><div class="line">    &#125;</div><div class="line">``` </div><div class="line">直接与网络层接触,直接返回给客户端</div><div class="line">### 再看下与getWriter</div><div class="line">    实际上返回的是CoyoteWriter类,查看其源码write方法</div><div class="line">``` code</div><div class="line"></div><div class="line">protected OutputBuffer ob;</div><div class="line">@Override</div><div class="line">    public void write(char buf[], int off, int len) &#123;</div><div class="line"></div><div class="line">        if (error) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            ob.write(buf, off, len);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            error = true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其实是写到一个buffer里面,tomcat再从buffer里面读取,这部分逻辑我还没查清楚,有可能读跟写是并行的.</p>
<h4 id="所以tomcat要杜绝你即使用先来看下getOutputStream-又使用getWriter-防止出现数据的不连续性"><a href="#所以tomcat要杜绝你即使用先来看下getOutputStream-又使用getWriter-防止出现数据的不连续性" class="headerlink" title="所以tomcat要杜绝你即使用先来看下getOutputStream,又使用getWriter.防止出现数据的不连续性."></a>所以tomcat要杜绝你即使用先来看下getOutputStream,又使用getWriter.防止出现数据的不连续性.</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xuyuli.github.io/2017/05/10/hashMap的实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xyl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/bb.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/10/hashMap的实现原理/" itemprop="url">hashMap的实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-10T14:42:14+08:00">
                2017-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="post"><br><br># <a href="http://www.cnblogs.com/chengxiao/p/6059914.html" target="_blank" rel="external">HashMap实现原理及源码分析</a><br><br><div class="postBody"><br><br><div id="cnblogs_post_body"><br><br>　　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。<br><br><span style="font-size: 18px;"><strong>目录</strong></span><br><br><span style="color: #000000; font-size: 18px;"><strong>　<span style="font-size: 16px;">　<span style="color: #993366;">一、<span style="font-size: 15px;"><a href="#t1"><span style="color: #993366;">什么是哈希表</span></a></span></span></span></strong></span><br><br><span style="color: #993366; font-size: 15px;"><strong>　　二、<a href="#t2"><span style="color: #993366;">HashMap实现原理</span></a></strong></span><br><br><span style="color: #993366; font-size: 15px;"><strong>　　三、<a href="#t3"><span style="color: #993366;">为何HashMap的数组长度一定是2的次幂？</span></a></strong></span><br><br><span style="color: #993366; font-size: 15px;"><strong>　　四、<a href="#t4"><span style="color: #993366;">重写equals方法需同时重写hashCode方法</span></a></strong></span><br><br><span style="color: #993366; font-size: 15px;"><strong>　　五、<a href="#t5"><span style="color: #993366;">总结</span></a></strong></span><br><br># <a name="t1"></a>一、什么是哈希表<br><br>　　在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能<br><br>　　<strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)<br><br>　　<strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)<br><br>　　<strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。<br><br>　　<strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。<br><br>　　我们知道，数据结构的物理存储结构只有两种：<span style="color: #ff0000;"><strong>顺序存储结构</strong></span>和<span style="color: #ff0000;"><strong>链式存储结构</strong><span style="color: #000000;">（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<span style="color: #ff0000;"><strong>哈希表的主干就是数组</strong></span>。</span></span><br><br><span style="color: #ff0000;"><span style="color: #000000;">　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</span><strong><span style="color: #000000;"><br></span></strong></span><br><br><span style="color: #ff0000;"><span style="color: #000000;">　　　　　　　　<span style="font-size: 18px; color: #ff0000;"><strong>存储位置 = f(关键字)</strong></span></span></span><br><br><span style="color: #ff0000;"><span style="color: #000000;"><span style="font-size: 18px; color: #ff0000;"><span style="color: #000000; font-size: 15px;">　其中，这个函数f一般称为<strong>哈希函数</strong>，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</span></span></span></span><br><br><span style="color: #ff0000;"><span style="color: #000000;"><span style="font-size: 18px; color: #ff0000;"><span style="color: #000000; font-size: 15px;">　　<img src="http://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113180447499-1953916974.png" alt=""></span></span></span></span><br><br><span style="color: #ff0000;"><span style="color: #000000;"><span style="font-size: 18px; color: #ff0000;"><span style="color: #000000; font-size: 15px;">　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</span></span></span></span><br><br><span style="color: #ff0000;"><span style="color: #000000;"><span style="font-size: 18px; color: #ff0000;"><span style="color: #000000; font-size: 15px;">　　<span style="font-size: 16px;"><strong>哈希冲突</strong></span></span></span></span></span><br><br><span style="color: #ff0000;"><span style="color: #000000;"><span style="font-size: 18px; color: #ff0000;"><span style="color: #000000; font-size: 15px;">　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<span style="color: #ff0000;"><strong>哈希冲突</strong></span>，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单</strong>和<strong>散列地址分布均匀,</strong>但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是<strong>数组+链表</strong>的方式，</span></span></span></span><br><br># <a name="t2"></a>二、HashMap实现原理<br><br>　HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。<br><br><div class="cnblogs_code"><br><br><pre><span style="color: #008000;">//</span><span style="color: #008000;">HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。</span><br><span style="color: #0000ff;">transient</span> Entry<k,v>[] table = (Entry<k,v>[]) EMPTY_TABLE;</k,v></k,v></pre><br><br></div>

<p> Entry是HashMap中的一个静态内部类。代码如下</p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre>    <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span> Entry<k,v> <span style="color: #0000ff;">implements</span> Map.Entry<k,v> <span style="color: #000000;">{</span> <span style="color: #0000ff;">final</span> <span style="color: #000000;">K key;
        V value;
        Entry</span><k,v> <span style="color: #000000;">next;<span style="color: #008000;">//存储指向下一个Entry的引用，单链表结构</span></span><span style="color: #0000ff;">int</span> <span style="color: #000000;">hash;<span style="color: #008000;">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><span style="color: #008000;">/**</span> <span style="color: #008000;">* Creates new entry.</span> <span style="color: #008000;">*/</span> <span style="color: #000000;">Entry(</span><span style="color: #0000ff;">int</span> h, K k, V v, Entry<k,v> <span style="color: #000000;">n) {
            value</span> = <span style="color: #000000;">v;
            next</span> = <span style="color: #000000;">n;
            key</span> = <span style="color: #000000;">k;
            hash</span> = <span style="color: #000000;">h;
        }</span> </k,v></k,v></k,v></k,v></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p> 所以，HashMap的整体结构如下</p>
<p><span style="color: #000000; font-size: 16px;"><img src="http://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113235348670-746615111.png" alt=""><span style="font-size: 15px;">　　</span></span></p>
<p><span style="font-size: 15px;">　　<span style="color: #000000;"><strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，急需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong></span></span></p>
<p>其他几个重要字段</p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre><span style="color: #008000;">//</span><span style="color: #008000;">实际存储的key-value键值对的个数</span>
<span style="color: #0000ff;">transient</span> <span style="color: #0000ff;">int</span> <span style="color: #000000;">size;</span> <span style="color: #008000;">//</span><span style="color: #008000;">阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到</span>
<span style="color: #0000ff;">int</span> <span style="color: #000000;">threshold;</span> <span style="color: #008000;">//</span><span style="color: #008000;">负载因子，代表了table的填充度有多少，默认是0.75</span>
<span style="color: #0000ff;">final</span> <span style="color: #0000ff;">float</span> <span style="color: #000000;">loadFactor;</span> <span style="color: #008000;">//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果</span><span style="color: #008000;">期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException</span>
<span style="color: #0000ff;">transient</span> <span style="color: #0000ff;">int</span> modCount;</pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p>
<p>initialCapacity默认为16，loadFactory默认为0.75</p>
<p>我们看下其中一个</p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre><span style="color: #0000ff;">public</span> HashMap(<span style="color: #0000ff;">int</span> initialCapacity, <span style="color: #0000ff;">float</span> <span style="color: #000000;">loadFactor) {
　　　　　<span style="color: #008000;">//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1<<30(2<sup>30)</30(2<sup></span></span><span style="color: #0000ff;">if</span> (initialCapacity < 0<span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("Illegal initial capacity: " + <span style="color: #000000;">initialCapacity);</span> <span style="color: #0000ff;">if</span> (initialCapacity > <span style="color: #000000;">MAXIMUM_CAPACITY)
            initialCapacity</span> = <span style="color: #000000;">MAXIMUM_CAPACITY;</span> <span style="color: #0000ff;">if</span> (loadFactor <= 0="" ||="" <span="" style="color: #000000;">Float.isNaN(loadFactor)) <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("Illegal load factor: " + <span style="color: #000000;">loadFactor);</span> <span style="color: #0000ff;">this</span>.loadFactor = <span style="color: #000000;">loadFactor;
        threshold</span> = <span style="color: #000000;">initialCapacity;

        init();<span style="color: #008000;">//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span>
    }</span></=></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p>　　从上面这段代码我们可以看出，<strong><span style="color: #000000;">在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</span></strong></p>
<p><span style="color: #000000; font-size: 14px;">　　OK,接下来我们来看看put操作的实现吧</span></p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre>    <span style="color: #0000ff;">public</span> <span style="color: #000000;">V put(K key, V value) {
        <span style="color: #008000;">//如果table数组为空数组{}，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1</span></span><span style="color: #008000;"><<4(2<sup>4=16)</4(2<sup></span> <span style="color: #0000ff;">if</span> (table == <span style="color: #000000;">EMPTY_TABLE) {
            inflateTable(threshold);
        }</span> <span style="color: #008000;">//</span><span style="color: #008000;">如果key为null，存储位置为table[0]或table[0]的冲突链上</span>
        <span style="color: #0000ff;">if</span> (key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">putForNullKey(value);</span> <span style="color: #0000ff;">int</span> hash = hash(key);<span style="color: #008000;">//</span><span style="color: #008000;">对key的hashcode进一步计算，确保散列均匀</span>
        <span style="color: #0000ff;">int</span> i = indexFor(hash, table.length);<span style="color: #008000;">//</span><span style="color: #008000;">获取在table中的实际位置</span>
        <span style="color: #0000ff;">for</span> (Entry<k,v> e = table[i]; e != <span style="color: #0000ff;">null</span>; e = <span style="color: #000000;">e.next) {</span> <span style="color: #008000;">//</span><span style="color: #008000;">如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span>
 <span style="color: #000000;">Object k;</span> <span style="color: #0000ff;">if</span> (e.hash == hash && ((k = e.key) == key || <span style="color: #000000;">key.equals(k))) {
                V oldValue</span> = <span style="color: #000000;">e.value;
                e.value</span> = <span style="color: #000000;">value;
                e.recordAccess(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">);</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">oldValue;
            }
        }
        modCount</span>++<span style="color: #000000;">;<span style="color: #008000;">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span>
        addEntry(hash, key, value, i);</span><span style="color: #008000;">//</span><span style="color: #008000;">新增一个entry</span>
        <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }</span> </k,v></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p> 先来看看inflateTable这个方法</p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> inflateTable(<span style="color: #0000ff;">int</span> <span style="color: #000000;">toSize) {</span> <span style="color: #0000ff;">int</span> capacity = <span style="color: #000000;">roundUpToPowerOf2(toSize);<span style="color: #008000;">//capacity一定是2的次幂</span>
        threshold</span> = (<span style="color: #0000ff;">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1<span style="color: #000000;">);<span style="color: #008000;">//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1</span>
        table</span> = <span style="color: #0000ff;">new</span> <span style="color: #000000;">Entry[capacity];
        initHashSeedAsNeeded(capacity);
    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p>　　inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> roundUpToPowerOf2(<span style="color: #0000ff;">int</span> <span style="color: #000000;">number) {</span> <span style="color: #008000;">//</span> <span style="color: #008000;">assert number >= 0 : "number must be non-negative";</span>
        <span style="color: #0000ff;">return</span> number >= <span style="color: #000000;">MAXIMUM_CAPACITY</span> ? <span style="color: #000000;">MAXIMUM_CAPACITY
                : (number</span> > 1) ? Integer.highestOneBit((number - 1) << 1) : 1<span style="color: #000000;">;
    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p>
<p>hash函数</p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre><span style="color: #008000;">//</span><span style="color: #008000;">这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀</span>
<span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> <span style="color: #000000;">hash(Object k) {</span> <span style="color: #0000ff;">int</span> h = <span style="color: #000000;">hashSeed;</span> <span style="color: #0000ff;">if</span> (0 != h && k <span style="color: #0000ff;">instanceof</span> <span style="color: #000000;">String) {</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">sun.misc.Hashing.stringHash32((String) k);
        }

        h</span> ^= <span style="color: #000000;">k.hashCode();

        h</span> ^= (h >>> 20) ^ (h >>> 12<span style="color: #000000;">);</span> <span style="color: #0000ff;">return</span> h ^ (h >>> 7) ^ (h >>> 4<span style="color: #000000;">);
    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre><span style="color: #008000;">　　/**</span> <span style="color: #008000;">* 返回数组下标</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> indexFor(<span style="color: #0000ff;">int</span> h, <span style="color: #0000ff;">int</span> <span style="color: #000000;">length) {</span> <span style="color: #0000ff;">return</span> h & (length-1<span style="color: #000000;">);
    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p>
<div class="cnblogs_code"><br><br><pre> <span style="color: #ff0000;">1  0  0  1  0<br>    &amp;   0  1  1  1  1<br>    <strong><strong><strong><strong>__</strong></strong></strong></strong><br>        0  0  0  1  0    = 2</span></pre><br><br></div>

<p>　　最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p>
<p>所以最终存储位置的确定流程是这样的：</p>
<p><img src="http://images2015.cnblogs.com/blog/1024555/201611/1024555-20161115133556388-1098209938.png" alt=""></p>
<p>再来看看addEntry的实现：</p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre><span style="color: #0000ff;">void</span> addEntry(<span style="color: #0000ff;">int</span> hash, K key, V value, <span style="color: #0000ff;">int</span> <span style="color: #000000;">bucketIndex) {</span> <span style="color: #0000ff;">if</span> ((size >= threshold) && (<span style="color: #0000ff;">null</span> != <span style="color: #000000;">table[bucketIndex])) {
            resize(</span>2 * <span style="color: #000000;">table.length);<span style="color: #008000;">//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span>
            hash</span> = (<span style="color: #0000ff;">null</span> != key) ? hash(key) : 0<span style="color: #000000;">;
            bucketIndex</span> = <span style="color: #000000;">indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p>　　通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p>
<h1 id="三、为何HashMap的数组长度一定是2的次幂？"><a href="#三、为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="三、为何HashMap的数组长度一定是2的次幂？"></a><a name="t3"></a>三、为何HashMap的数组长度一定是2的次幂？</h1><p>我们来继续看上面提到的resize方法</p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre> <span style="color: #0000ff;">void</span> resize(<span style="color: #0000ff;">int</span> <span style="color: #000000;">newCapacity) {
        Entry[] oldTable</span> = <span style="color: #000000;">table;</span> <span style="color: #0000ff;">int</span> oldCapacity = <span style="color: #000000;">oldTable.length;</span> <span style="color: #0000ff;">if</span> (oldCapacity == <span style="color: #000000;">MAXIMUM_CAPACITY) {
            threshold</span> = <span style="color: #000000;">Integer.MAX_VALUE;</span> <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }

        Entry[] newTable</span> = <span style="color: #0000ff;">new</span> <span style="color: #000000;">Entry[newCapacity];
        transfer(newTable, initHashSeedAsNeeded(newCapacity));
        table</span> = <span style="color: #000000;">newTable;
        threshold</span> = (<span style="color: #0000ff;">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1<span style="color: #000000;">);
    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre><span style="color: #0000ff;">void</span> transfer(Entry[] newTable, <span style="color: #0000ff;">boolean</span> <span style="color: #000000;">rehash) {</span> <span style="color: #0000ff;">int</span> newCapacity = <span style="color: #000000;">newTable.length;
　　　　　<span style="color: #008000;">//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）</span></span><span style="color: #0000ff;">for</span> (Entry<k,v> <span style="color: #000000;">e : table) {</span> <span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">null</span> != <span style="color: #000000;">e) {
                Entry</span><k,v> next = <span style="color: #000000;">e.next;</span> <span style="color: #0000ff;">if</span> <span style="color: #000000;">(rehash) {
                    e.hash</span> = <span style="color: #0000ff;">null</span> == e.key ? 0 <span style="color: #000000;">: hash(e.key);
                }</span> <span style="color: #0000ff;">int</span> i = <span style="color: #000000;">indexFor(e.hash, newCapacity);
　　　　　　　　　 <span style="color: #008000;">//将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。</span>
                e.next</span> = <span style="color: #000000;">newTable[i];
                newTable[i]</span> = <span style="color: #000000;">e;
                e</span> = <span style="color: #000000;">next;
            }
        }
    }</span></k,v></k,v></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p>　　这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p>
<p>　　hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p>
<p>　　<img src="http://images2015.cnblogs.com/blog/1024555/201611/1024555-20161115215812138-679881037.png" alt=""></p>
<p> 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p>
<p><img src="http://images2015.cnblogs.com/blog/1024555/201611/1024555-20161116001404732-625340289.png" alt=""></p>
<p>　　我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p>
<p><img src="http://images2015.cnblogs.com/blog/1024555/201611/1024555-20161116001717560-1455096254.png" alt=""></p>
<p>　　如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p>
<p>get方法</p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre> <span style="color: #0000ff;">public</span> <span style="color: #000000;">V get(Object key) {
　　　　 <span style="color: #008000;">//如果key为null,则直接去table[0]处去检索即可。</span></span><span style="color: #0000ff;">if</span> (key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">getForNullKey();
        Entry</span><k,v> entry = <span style="color: #000000;">getEntry(key);</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span> == entry ? <span style="color: #0000ff;">null</span> <span style="color: #000000;">: entry.getValue();
 }</span></k,v></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre><span style="color: #0000ff;">final</span> Entry<k,v> <span style="color: #000000;">getEntry(Object key) {</span> <span style="color: #0000ff;">if</span> (size == 0<span style="color: #000000;">) {</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }</span> <span style="color: #008000;">//</span><span style="color: #008000;">通过key的hashcode值计算hash值</span>
        <span style="color: #0000ff;">int</span> hash = (key == <span style="color: #0000ff;">null</span>) ? 0 <span style="color: #000000;">: hash(key);</span> <span style="color: #008000;">//</span><span style="color: #008000;">indexFor (hash&length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span>
        <span style="color: #0000ff;">for</span> (Entry<k,v> e = <span style="color: #000000;">table[indexFor(hash, table.length)];
             e</span> != <span style="color: #0000ff;">null</span><span style="color: #000000;">;
             e</span> = <span style="color: #000000;">e.next) {
            Object k;</span> <span style="color: #0000ff;">if</span> (e.hash == hash && <span style="color: #000000;">((k</span> = e.key) == key || (key != <span style="color: #0000ff;">null</span> && <span style="color: #000000;">key.equals(k))))</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">e;
        }</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }</span> </k,v></k,v></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p>　　可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p>
<h1 id="四、重写equals方法需同时重写hashCode方法"><a href="#四、重写equals方法需同时重写hashCode方法" class="headerlink" title="四、重写equals方法需同时重写hashCode方法"></a><a name="t4"></a>四、重写equals方法需同时重写hashCode方法</h1><p>　　关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p>
<div class="cnblogs_code"><br><br><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<pre><span style="color: #008000;">/**</span> <span style="color: #008000;">* Created by chengxiao on 2016/11/15.</span> <span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> <span style="color: #000000;">MyTest {</span> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span> <span style="color: #000000;">Person{</span> <span style="color: #0000ff;">int</span> <span style="color: #000000;">idCard;
        String name;</span> <span style="color: #0000ff;">public</span> Person(<span style="color: #0000ff;">int</span> <span style="color: #000000;">idCard, String name) {</span> <span style="color: #0000ff;">this</span>.idCard = <span style="color: #000000;">idCard;</span> <span style="color: #0000ff;">this</span>.name = <span style="color: #000000;">name;
        }
        @Override</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> <span style="color: #000000;">equals(Object o) {</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span> == <span style="color: #000000;">o) {</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }</span> <span style="color: #0000ff;">if</span> (o == <span style="color: #0000ff;">null</span> || getClass() != <span style="color: #000000;">o.getClass()){</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
            Person person</span> = <span style="color: #000000;">(Person) o;</span> <span style="color: #008000;">//</span><span style="color: #008000;">两个对象是否等值，通过idCard来确定</span>
            <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.idCard == <span style="color: #000000;">person.idCard;
        }

    }</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">main(String []args){
        HashMap</span><person,string> map = <span style="color: #0000ff;">new</span> HashMap<person, string=""><span style="color: #000000;">();
        Person person</span> = <span style="color: #0000ff;">new</span> Person(1234,"乔峰"<span style="color: #000000;">);</span> <span style="color: #008000;">//</span><span style="color: #008000;">put到hashmap中去</span>
        map.put(person,"天龙八部"<span style="color: #000000;">);</span> <span style="color: #008000;">//</span><span style="color: #008000;">get取出，从逻辑上讲应该能输出“天龙八部”</span>
        System.out.println("结果:"+map.get(<span style="color: #0000ff;">new</span> Person(1234,"萧峰"<span style="color: #000000;">)));
    }
}</span></person,></person,string></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</span></div>

<p></p></div><p></p>
<p>实际输出结果：</p>
<div class="cnblogs_code"><br><br><pre><span style="color: #ff0000;">结果：null</span></pre><br><br></div>

<p>　　如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p>
<p>　　所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><a name="t5"></a>五、总结</h1><p>　　本文描述了HashMap的实现原理，并结合源码做了进一步的分析，也涉及到一些源码细节设计缘由，最后简单介绍了为什么重写equals的时候需要重写hashCode方法。希望本篇文章能帮助到大家，同时也欢迎讨论指正，谢谢支持！</p>
<p></p></div><p></p>
<div style="display: block;" id="MySignature"><br><br><div style="margin-bottom: 10px; padding: 5px 10px; background-color: #D9FFFF; border: #53FF53 1px solid;"><br><br>作者： <a href="http://www.cnblogs.com/chengxiao/" target="_blank" rel="external">dreamcatcher-cx</a><br><br>出处： <a href="http://www.cnblogs.com/chengxiao/" target="_blank" rel="external"><a href="http://www.cnblogs.com/chengxiao/" target="_blank" rel="external">http://www.cnblogs.com/chengxiao/</a></a><br><br>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在页面明显位置给出原文链接。<br><br></div>

<p></p></div><p></p>
<div id="blog_post_info_block"><br><br><div id="BlogPostCategory">分类: <a href="http://www.cnblogs.com/chengxiao/category/909714.html" target="_blank" rel="external">java集合框架</a></div>

<div id="blog_post_info"><br><br><div id="green_channel"><a href="javascript:void(0" target="_blank" rel="external">好文要顶</a>;) <a href="javascript:void(0" target="_blank" rel="external">关注我</a>;) <a href="javascript:void(0" target="_blank" rel="external">收藏该文</a>;) <a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/icon_weibo_24.png" alt=""></a>; “分享至新浪微博”) <a href="javascript:void(0" target="_blank" rel="external"><img src="//common.cnblogs.com/images/wechat.png" alt=""></a>; “分享至微信”)</div>

<div id="author_profile"><br><br><div id="author_profile_info" class="author_profile_info"><a href="http://home.cnblogs.com/u/chengxiao/" target="_blank" rel="external"><img src="//pic.cnblogs.com/face/1024555/20170217101538.png" alt=""></a><br><br><div id="author_profile_detail" class="author_profile_info"><a href="http://home.cnblogs.com/u/chengxiao/" target="_blank" rel="external">dreamcatcher-cx</a><br><a href="http://home.cnblogs.com/u/chengxiao/followees" target="_blank" rel="external">关注 - 19</a><br><a href="http://home.cnblogs.com/u/chengxiao/followers" target="_blank" rel="external">粉丝 - 21</a></div>

<p></p></div><p></p>
<div id="author_profile_follow"><a href="javascript:void(0" target="_blank" rel="external">+加关注</a>;)</div>

<p></p></div><p></p>
<div id="div_digg"><br><br><div class="diggit" onclick="votePost(6059914,'Digg')"><span class="diggnum" id="digg_count">11</span></div>

<div class="buryit" onclick="votePost(6059914,'Bury')"><span class="burynum" id="bury_count">0</span></div>

<p></p></div><p></p>
<p></p></div><p></p>
<div id="post_next_prev"><a href="http://www.cnblogs.com/chengxiao/p/6032183.html" target="_blank" rel="external">«</a> 上一篇：<a href="http://www.cnblogs.com/chengxiao/p/6032183.html" title="发布于2016-11-06 22:34" target="_blank" rel="external">Oracle约束(Constraint)详解</a><br><a href="http://www.cnblogs.com/chengxiao/p/6103002.html" target="_blank" rel="external">»</a> 下一篇：<a href="http://www.cnblogs.com/chengxiao/p/6103002.html" title="发布于2016-11-26 12:46" target="_blank" rel="external">图解排序算法(一)之3种简单排序(选择，冒泡，直接插入)</a><br></div>

<p></p></div><p></p>
<p></p></div><p></p>
<div class="postDesc">posted @ <span id="post-date">2016-11-16 00:27</span> <a href="http://www.cnblogs.com/chengxiao/" target="_blank" rel="external">dreamcatcher-cx</a> 阅读(<span id="post_view_count">4211</span>) 评论(<span id="post_comment_count">2</span>) <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6059914" target="_blank" rel="external">编辑</a> <a href="#">收藏</a></div>

<p></p></div><p></p>
<script type="text/javascript">var allowComments=true,cb_blogId=304993,cb_entryId=6059914,cb_blogApp=currentBlogApp,cb_blogUserGuid='8319750a-5977-e611-9fc1-ac853d9f53cc',cb_entryCreatedDate='2016/11/16 0:27:00';loadViewCount(cb_entryId);</script>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xuyuli.github.io/2017/05/10/转载的面试经验1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xyl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/bb.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/10/转载的面试经验1/" itemprop="url">转载的面试经验1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-10T14:42:14+08:00">
                2017-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="article-meta"><a href="/2017/04/22/个人面经/"><time datetime="2017-04-22T06:51:17.000Z" itemprop="datePublished">2017-04-22</time></a></div>

<div class="article-inner"><input class="isFancy" type="hidden"><br><br><header class="article-header"><br><br># 个人面经（百度、腾讯、鹏元数据、行云智能数据岗）<br><br></header><br><br><div class="article-info article-info-post"><br><br><div class="article-tag tagcloud"><br><br>*   <a href="/tags/Interview/">Interview</a><br><br></div>

<p></p></div><p></p>
<div class="article-entry" itemprop="articleBody"><br><br>记录自找工作以来个人的面试经历与一些思考。<br><br><a id="more"></a><br><br>## <a href="#百度数据挖掘一面（电话面）" title="百度数据挖掘一面（电话面）"></a>百度数据挖掘一面（电话面）<br><br>1.  介绍项目<br>2.  问题<br>3.  基础知识：java的多态、map和垃圾回收<br>4.  如何用网络知识让抢火车票更快<br>5.  快排的思想、时间和空间复杂度、如果是整数排序有没有O(n)的解法<br>6.  逻辑回归线性回归区别<br>7.  linux怎么查看某文件当前被哪些进程访问<br>8.  vim如何查找替换<br><br>## <a href="#百度运维一面（电话面）" title="百度运维一面（电话面）"></a>百度运维一面（电话面）<br><br>1.  聊项目<br>2.  python字符串的替换<br>3.  SQL的优化<br>4.  LInux 如何找进程杀进程<br><br>## <a href="#百度运维二面（现场面）" title="百度运维二面（现场面）"></a>百度运维二面（现场面）<br><br>1.  聊项目<br>2.  手写冒泡<br><br>## <a href="#行云智能一面（现场面）" title="行云智能一面（现场面）"></a>行云智能一面（现场面）<br><br>遇到面试官是西电校友<br><br>1.  聊项目<br>2.  CNN的思想：pooling的方式、卷积的思想<br>3.  设计模式有什么了解<br>4.  多线程多进程的了解<br>5.  快排的思想<br>6.  手写代码二叉树删除<br><br>## <a href="#中科乐创一面（现场面）" title="中科乐创一面（现场面）"></a>中科乐创一面（现场面）<br><br>最尴尬的一次，面试官是南洋理工的，聊了聊我的项目就似乎对我不感兴趣，就开始和我聊家常。。。<br><br>## <a href="#鹏元数据一面（现场面）" title="鹏元数据一面（现场面）"></a>鹏元数据一面（现场面）<br><br>1.  聊项目<br>2.  做了张试卷如<br><br><em>   推导极大似然估计
</em>   聚类与分类区别，列举常用聚类算法及程序包<br><em>   一些简单的SQL命令
</em>   编程题：列举一串数字内奇偶数出现次数及引申出的结合他们业务的评级转换矩阵的打印<br><br>## <a href="#腾讯基础研究一面（现场面）" title="腾讯基础研究一面（现场面）"></a>腾讯基础研究一面（现场面）<br><br>1.  聊项目<br>2.  聚类与分类区别，常用聚类算法<br>    思考：诸如此类列举算法的问题，最好是迅速流利的列举出多个，不要有迟疑，不过对于其基本含义要有了解。<br>3.  场景题，两个含有数字的文件，找出同时出现在两个文件内的数字；若文件太大放不进内存该怎么办？<br>    思考：这种问题可小可大，可难可易。因为哪怕再小的问题在规模变大也就是涉及到大数据都是不简单的，这个问题，对于小文件，两三行代码即可搞定，那么你写出来之后，面试官基本上就会进一步问你：如果文件很大，无法同时把这两个文件装进内存，怎么办？我当时回答的是用Pandas的read_csv分块读取，这是个很不好的回答，因为掉包不是基本功。我回头想了想，也许这个答案是用generator比较好。<br><br></div>

<p></p></div><p></p>
<div class="copyright"><br><br><span>Title:</span><a href="/2017/04/22/个人面经/">个人面经（百度、腾讯、鹏元数据、行云智能数据岗）</a><br><br><span>Author:</span><a href="/" title="Back to Homepage">江南消夏</a><br><br><span>Created:</span>2017-04-22, 14:51:17<br><br><span>Updated:</span>2017-04-25, 09:23:44<br><br><span>Full URL:</span><a href="/2017/04/22/个人面经/" title="个人面经（百度、腾讯、鹏元数据、行云智能数据岗）">http://frankchen.xyz/2017/04/22/个人面经/</a> <span class="copy-path" data-clipboard-text="From http://frankchen.xyz/2017/04/22/个人面经/　　By 江南消夏" title="Copy Article's Link &amp; Author"></span><script>var clipboard = new Clipboard(‘.copy-path’);</script><br><br><span>License:</span> <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank" rel="external">“CC BY-NC-SA 4.0”</a> Keep Link &amp; Author if Distribute.<br><br></div>

<nav id="article-nav"><br><br><div id="article-nav-newer" class="article-nav-title"><a href="/2017/05/04/Basic-Algorithms-in-Python/">面试常见基础算法:排序/查找/树的遍历等（python版）</a></div><br><br><div id="article-nav-older" class="article-nav-title"><a href="/2017/04/20/Ubuntu-16-04下为TITAN-1080-显卡安装驱动-Cuda-CudNN-及Gpu版TensorFlow/">Ubuntu 16.04下为TITAN 1080 显卡安装驱动(Cuda&amp;CudNN)及Gpu版TensorFlow</a></div><br><br></nav>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/bb.png"
               alt="xyl" />
          <p class="site-author-name" itemprop="name">xyl</p>
           
              <p class="site-description motion-element" itemprop="description">淡泊明志,宁静致远</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xuyuli" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="" target="_blank" title="Others">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Others
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xyl</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
