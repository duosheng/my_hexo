---
title: 浅析事务原理
date: 2017-05-16 10:28:10
tags:
---

## 什么是事务
    事务是对一组对数据操作的封装,尤其是多线程对共享数据的操作,由于要符合人类的逻辑正确性,所以制定了一套标准,来规范对共享数据的操作  
    这种规范,就是事务.其核心,就是  锁   +   并行.  还有就是 多版本并发控制(mvcc) 来解决锁的效率低下.
    
### 事务的特性
acid 原子性,一致性,隔离性,持久性
#### 原子性
    关于原子性,有很多的文章,但是都太难懂了.上面说了,事务是对一直对数据操作的封装.原子性,要么全部成功,要么全部失败.这是事务最基本的规范,为什么要制定这个规范,这个很好理解,如果没有这个规范,那么数据就要乱了
    那么,数据库是怎么实现的呢,其实很简单,就是记日志(undo日志).其实很多看似很高大上的特性都是使用很简单的原理来实现的.当实务操作之前,记录undo日志(准确的说是在每个对数据的操作前都记录undo日志),当事务失败时,使用undo日志将数据复原.是不是很简单,就像我们发布版本的时候一样,发布前记录一个备份,发布失败,就使用备份代码.
#### 一致性
    其实这个一致性是基于原子性的,对原子性的补充.当人们拥有原子性的准则时候,就不怕事务执行失败了,满足人们的逻辑.但是,人们又发现.如果多线程的情况下,比如线程1,a账号给b账号转账100元.线程2,c账号给a账号转账100元.如果在线程2执行后,线程1失败了,那么它将回滚,将a账号的数据复原.这样的话就不行了,因为c给a的钱没了.
    这个就不符合人类的逻辑.所以,又制定了一致性原则.只要记住,这个原则一定要符合人类的逻辑,这两笔转账都要符合逻辑,不会出现c转账了,钱没了.
    那么怎么实现一致性呢,其实也很简单,就是加锁.当线程1执行时,对a,b账号加锁,当执行完,再释放锁.这样其实就达到了一致性.
    那样,我们有没有发现,其实这时候,事务跟实物的关系  就好像是一个队列,所有的事务操作都在这个队列里面,事务跟事务的关系只能是要么你在我前面,要么你在我后面,绝不会你在我内部.
    这样,事务的一致性是达到了,但是效率极低,这个大家也能很快想到,锁的级别越高,范围越广,其他线程等待的时间越长,效率越低.
#### 隔离性
    其实,隔离性就是人们为了满足性能,而对一致性产生的破坏.人们发现,如果严格执行一致性,所有事务操作都是串行的,那么效率极低,所以人们就发明了隔离性这个东西,来对一些操作做并行话处理,这样既能达到数据安全,又能获取一定的效率.
    这个时候我们就来分析下,事务操作的组合有哪几种.其实也很简单,排列组合:
    读读,读写,写读,写写.4种.这四种,容易产生问题的有哪些呢,读读,其实是安全的,写写,优化性不高(难度很大),能优化的就只有,读写,写读了.
    那么,这四种,哪些可以并行操作呢,这就形成了隔离性的4个隔离级别:由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题.
    这四个隔离级别,其实对锁的封装.锁分读锁,写锁两种.来跟上面的4种排列组合对应.就产生了4种隔离级别.
    隔离级别就是对数据安全的程度划分.Serializable就是严格的串行,所有的读写组合都排队,这个可以解决所有的逻辑问题,但效率最低.
#### mvcc 多版本并发控制
    现在的数据库大多采用mvcc的设计模式,他能达到效率跟逻辑正确的平衡效果.上面说了,可优化的有读写,写读操作.如果只使用加锁策略,效率很低,因为我在写的时候,其他人读都不行.
    那么怎么办呢,大家想想,我们很多人一起开发同一个项目的时候怎么做的.对,开一个版本号.比如说,线程1,a给b转账.这个时候线程2,来读取b的账号余额.那怎么办呢?
    线程1读取的时候,新建个数据版本1(原来的数据版本是0).那么线程2来的时候,就读取版本0,这个就规避了并发产生的逻辑问题.当线程1执行完,将数据版本0删除,那么其他的线程就来读取线程1的版本.万事大吉!ok了
    
